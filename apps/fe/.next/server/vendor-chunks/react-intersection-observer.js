"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-intersection-observer";
exports.ids = ["vendor-chunks/react-intersection-observer"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-intersection-observer/dist/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/react-intersection-observer/dist/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InView: () => (/* binding */ InView),\n/* harmony export */   defaultFallbackInView: () => (/* binding */ defaultFallbackInView),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   useInView: () => (/* binding */ useInView),\n/* harmony export */   useOnInView: () => (/* binding */ useOnInView)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ InView,defaultFallbackInView,observe,useInView,useOnInView auto */ var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n// src/InView.tsx\n\n// src/observe.ts\nvar observerMap = /* @__PURE__ */ new Map();\nvar RootIds = /* @__PURE__ */ new WeakMap();\nvar rootId = 0;\nvar unsupportedValue;\nfunction defaultFallbackInView(inView) {\n    unsupportedValue = inView;\n}\nfunction getRootId(root) {\n    if (!root) return \"0\";\n    if (RootIds.has(root)) return RootIds.get(root);\n    rootId += 1;\n    RootIds.set(root, rootId.toString());\n    return RootIds.get(root);\n}\nfunction optionsToId(options) {\n    return Object.keys(options).sort().filter((key)=>options[key] !== void 0).map((key)=>{\n        return `${key}_${key === \"root\" ? getRootId(options.root) : options[key]}`;\n    }).toString();\n}\nfunction createObserver(options) {\n    const id = optionsToId(options);\n    let instance = observerMap.get(id);\n    if (!instance) {\n        const elements = /* @__PURE__ */ new Map();\n        let thresholds;\n        const observer = new IntersectionObserver((entries)=>{\n            entries.forEach((entry)=>{\n                var _a2;\n                const inView = entry.isIntersecting && thresholds.some((threshold)=>entry.intersectionRatio >= threshold);\n                if (options.trackVisibility && typeof entry.isVisible === \"undefined\") {\n                    entry.isVisible = inView;\n                }\n                (_a2 = elements.get(entry.target)) == null ? void 0 : _a2.forEach((callback)=>{\n                    callback(inView, entry);\n                });\n            });\n        }, options);\n        thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [\n            options.threshold || 0\n        ]);\n        instance = {\n            id,\n            observer,\n            elements\n        };\n        observerMap.set(id, instance);\n    }\n    return instance;\n}\nfunction observe(element, callback, options = {}, fallbackInView = unsupportedValue) {\n    if (typeof window.IntersectionObserver === \"undefined\" && fallbackInView !== void 0) {\n        const bounds = element.getBoundingClientRect();\n        callback(fallbackInView, {\n            isIntersecting: fallbackInView,\n            target: element,\n            intersectionRatio: typeof options.threshold === \"number\" ? options.threshold : 0,\n            time: 0,\n            boundingClientRect: bounds,\n            intersectionRect: bounds,\n            rootBounds: bounds\n        });\n        return ()=>{};\n    }\n    const { id, observer, elements } = createObserver(options);\n    const callbacks = elements.get(element) || [];\n    if (!elements.has(element)) {\n        elements.set(element, callbacks);\n    }\n    callbacks.push(callback);\n    observer.observe(element);\n    return function unobserve() {\n        callbacks.splice(callbacks.indexOf(callback), 1);\n        if (callbacks.length === 0) {\n            elements.delete(element);\n            observer.unobserve(element);\n        }\n        if (elements.size === 0) {\n            observer.disconnect();\n            observerMap.delete(id);\n        }\n    };\n}\n// src/InView.tsx\nfunction isPlainChildren(props) {\n    return typeof props.children !== \"function\";\n}\nvar InView = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        __publicField(this, \"node\", null);\n        __publicField(this, \"_unobserveCb\", null);\n        __publicField(this, \"lastInView\");\n        __publicField(this, \"handleNode\", (node)=>{\n            if (this.node) {\n                this.unobserve();\n                if (!node && !this.props.triggerOnce && !this.props.skip) {\n                    this.setState({\n                        inView: !!this.props.initialInView,\n                        entry: void 0\n                    });\n                    this.lastInView = this.props.initialInView;\n                }\n            }\n            this.node = node ? node : null;\n            this.observeNode();\n        });\n        __publicField(this, \"handleChange\", (inView, entry)=>{\n            const previousInView = this.lastInView;\n            this.lastInView = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            if (inView && this.props.triggerOnce) {\n                this.unobserve();\n            }\n            if (!isPlainChildren(this.props)) {\n                this.setState({\n                    inView,\n                    entry\n                });\n            }\n            if (this.props.onChange) {\n                this.props.onChange(inView, entry);\n            }\n        });\n        this.state = {\n            inView: !!props.initialInView,\n            entry: void 0\n        };\n        this.lastInView = props.initialInView;\n    }\n    componentDidMount() {\n        this.unobserve();\n        this.observeNode();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n            this.unobserve();\n            this.observeNode();\n        }\n    }\n    componentWillUnmount() {\n        this.unobserve();\n    }\n    observeNode() {\n        if (!this.node || this.props.skip) return;\n        const { threshold, root, rootMargin, trackVisibility, delay, fallbackInView } = this.props;\n        if (this.lastInView === void 0) {\n            this.lastInView = this.props.initialInView;\n        }\n        this._unobserveCb = observe(this.node, this.handleChange, {\n            threshold,\n            root,\n            rootMargin,\n            // @ts-expect-error\n            trackVisibility,\n            delay\n        }, fallbackInView);\n    }\n    unobserve() {\n        if (this._unobserveCb) {\n            this._unobserveCb();\n            this._unobserveCb = null;\n        }\n    }\n    render() {\n        const { children } = this.props;\n        if (typeof children === \"function\") {\n            const { inView, entry } = this.state;\n            return children({\n                inView,\n                entry,\n                ref: this.handleNode\n            });\n        }\n        const { as, triggerOnce, threshold, root, rootMargin, onChange, skip, trackVisibility, delay, initialInView, fallbackInView, ...props } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(as || \"div\", {\n            ref: this.handleNode,\n            ...props\n        }, children);\n    }\n};\n// src/useInView.tsx\n\nfunction useInView({ threshold, delay, trackVisibility, rootMargin, root, triggerOnce, skip, initialInView, fallbackInView, onChange } = {}) {\n    var _a2;\n    const [ref, setRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const callback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onChange);\n    const lastInViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(initialInView);\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        inView: !!initialInView,\n        entry: void 0\n    });\n    callback.current = onChange;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useInView.useEffect\": ()=>{\n            if (lastInViewRef.current === void 0) {\n                lastInViewRef.current = initialInView;\n            }\n            if (skip || !ref) return;\n            let unobserve;\n            unobserve = observe(ref, {\n                \"useInView.useEffect\": (inView, entry)=>{\n                    const previousInView = lastInViewRef.current;\n                    lastInViewRef.current = inView;\n                    if (previousInView === void 0 && !inView) {\n                        return;\n                    }\n                    setState({\n                        inView,\n                        entry\n                    });\n                    if (callback.current) callback.current(inView, entry);\n                    if (entry.isIntersecting && triggerOnce && unobserve) {\n                        unobserve();\n                        unobserve = void 0;\n                    }\n                }\n            }[\"useInView.useEffect\"], {\n                root,\n                rootMargin,\n                threshold,\n                // @ts-expect-error\n                trackVisibility,\n                delay\n            }, fallbackInView);\n            return ({\n                \"useInView.useEffect\": ()=>{\n                    if (unobserve) {\n                        unobserve();\n                    }\n                }\n            })[\"useInView.useEffect\"];\n        }\n    }[\"useInView.useEffect\"], // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        // If the threshold is an array, convert it to a string, so it won't change between renders.\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        ref,\n        root,\n        rootMargin,\n        triggerOnce,\n        skip,\n        trackVisibility,\n        fallbackInView,\n        delay\n    ]);\n    const entryTarget = (_a2 = state.entry) == null ? void 0 : _a2.target;\n    const previousEntryTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {\n        previousEntryTarget.current = entryTarget;\n        setState({\n            inView: !!initialInView,\n            entry: void 0\n        });\n        lastInViewRef.current = initialInView;\n    }\n    const result = [\n        setRef,\n        state.inView,\n        state.entry\n    ];\n    result.ref = result[0];\n    result.inView = result[1];\n    result.entry = result[2];\n    return result;\n}\n// src/useOnInView.tsx\n\nvar _a, _b;\nvar useSyncEffect = (_b = (_a = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect) != null ? _a : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect) != null ? _b : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useOnInView = (onIntersectionChange, { threshold, root, rootMargin, trackVisibility, delay, triggerOnce, skip } = {})=>{\n    const onIntersectionChangeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onIntersectionChange);\n    const observedElementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerCleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    const lastInViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    useSyncEffect({\n        \"useOnInView.useSyncEffect\": ()=>{\n            onIntersectionChangeRef.current = onIntersectionChange;\n        }\n    }[\"useOnInView.useSyncEffect\"], [\n        onIntersectionChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"useOnInView.useCallback\": (element)=>{\n            const cleanupExisting = {\n                \"useOnInView.useCallback.cleanupExisting\": ()=>{\n                    if (observerCleanupRef.current) {\n                        const cleanup = observerCleanupRef.current;\n                        observerCleanupRef.current = void 0;\n                        cleanup();\n                    }\n                }\n            }[\"useOnInView.useCallback.cleanupExisting\"];\n            if (element === observedElementRef.current) {\n                return observerCleanupRef.current;\n            }\n            if (!element || skip) {\n                cleanupExisting();\n                observedElementRef.current = null;\n                lastInViewRef.current = void 0;\n                return;\n            }\n            cleanupExisting();\n            observedElementRef.current = element;\n            let destroyed = false;\n            const destroyObserver = observe(element, {\n                \"useOnInView.useCallback.destroyObserver\": (inView, entry)=>{\n                    const previousInView = lastInViewRef.current;\n                    lastInViewRef.current = inView;\n                    if (previousInView === void 0 && !inView) {\n                        return;\n                    }\n                    onIntersectionChangeRef.current(inView, entry);\n                    if (triggerOnce && inView) {\n                        stopObserving();\n                    }\n                }\n            }[\"useOnInView.useCallback.destroyObserver\"], {\n                threshold,\n                root,\n                rootMargin,\n                trackVisibility,\n                delay\n            });\n            function stopObserving() {\n                if (destroyed) return;\n                destroyed = true;\n                destroyObserver();\n                observedElementRef.current = null;\n                observerCleanupRef.current = void 0;\n                lastInViewRef.current = void 0;\n            }\n            observerCleanupRef.current = stopObserving;\n            return observerCleanupRef.current;\n        }\n    }[\"useOnInView.useCallback\"], [\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        root,\n        rootMargin,\n        trackVisibility,\n        delay,\n        triggerOnce,\n        skip\n    ]);\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1Qjs7QUNFdkIsSUFBTSxjQUFjLG9CQUFJLElBT3RCO0FBRUYsSUFBTSxVQUErQyxvQkFBSSxRQUFRO0FBQ2pFLElBQUksU0FBUztBQUViLElBQUk7QUFRRyxTQUFTLHNCQUFzQixRQUE2QjtJQUNqRSxtQkFBbUI7QUFDckI7QUFNQSxTQUFTLFVBQVUsTUFBd0M7SUFDekQsSUFBSSxDQUFDLEtBQU0sUUFBTztJQUNsQixJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUcsUUFBTyxRQUFRLElBQUksSUFBSTtJQUM5QyxVQUFVO0lBQ1YsUUFBUSxJQUFJLE1BQU0sT0FBTyxTQUFTLENBQUM7SUFDbkMsT0FBTyxRQUFRLElBQUksSUFBSTtBQUN6QjtBQU9PLFNBQVMsWUFBWSxTQUFtQztJQUM3RCxPQUFPLE9BQU8sS0FBSyxPQUFPLEVBQ3ZCLEtBQUssRUFDTCxPQUNDLENBQUMsTUFBUSxRQUFRLEdBQXFDLE1BQU0sUUFFN0QsSUFBSSxDQUFDO1FBQ0osT0FBTyxHQUFHLEdBQUcsSUFDWCxRQUFRLFNBQ0osVUFBVSxRQUFRLElBQUksSUFDdEIsUUFBUSxHQUFxQyxDQUNuRDtJQUNGLENBQUMsRUFDQSxTQUFTO0FBQ2Q7QUFFQSxTQUFTLGVBQWUsU0FBbUM7SUFFekQsTUFBTSxLQUFLLFlBQVksT0FBTztJQUM5QixJQUFJLFdBQVcsWUFBWSxJQUFJLEVBQUU7SUFFakMsSUFBSSxDQUFDLFVBQVU7UUFFYixNQUFNLFdBQVcsb0JBQUksSUFBOEM7UUFDbkUsSUFBSTtRQUVKLE1BQU0sV0FBVyxJQUFJLHFCQUFxQixDQUFDO1lBQ3pDLFFBQVEsUUFBUSxDQUFDO2dCQXRFdkIsSUFBQUE7Z0JBeUVRLE1BQU0sU0FDSixNQUFNLGtCQUNOLFdBQVcsS0FBSyxDQUFDLFlBQWMsTUFBTSxxQkFBcUIsU0FBUztn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QUNWO2dCQUNGOztZQUVBLElBQUksWUFBWSxtQkFBbUIsU0FBUztnQkFDMUMsT0FBTyxtQkFBbUI7WUFDNUI7WUFFQSxJQUFJLENBQUMsV0FBVyxNQUFNO2dCQUNwQixnQkFBZ0I7Z0JBQ2hCLG1CQUFtQixVQUFVO2dCQUM3QixjQUFjLFVBQVU7Z0JBQ3hCO1lBQ0Y7WUFFQSxnQkFBZ0I7WUFFaEIsbUJBQW1CLFVBQVU7WUFDN0IsSUFBSSxZQUFZO1lBRWhCLE1BQU0sa0JBQWtCLFFBQ3RCOzJEQUNBLENBQUMsUUFBUTtvQkFDUCxNQUFNLGlCQUFpQixjQUFjO29CQUNyQyxjQUFjLFVBQVU7b0JBR3hCLElBQUksbUJBQW1CLFVBQWEsQ0FBQyxRQUFRO3dCQUMzQztvQkFDRjtvQkFFQSx3QkFBd0IsUUFDdEIsUUFDQTtvQkFFRixJQUFJLGVBQWUsUUFBUTt3QkFDekIsY0FBYztvQkFDaEI7Z0JBQ0Y7MERBQ0E7Z0JBQ0U7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7WUFDRjtZQUdGLFNBQVMsZ0JBQWdCO2dCQUd2QixJQUFJLFVBQVc7Z0JBQ2YsWUFBWTtnQkFDWixnQkFBZ0I7Z0JBQ2hCLG1CQUFtQixVQUFVO2dCQUM3QixtQkFBbUIsVUFBVTtnQkFDN0IsY0FBYyxVQUFVO1lBQzFCO1lBRUEsbUJBQW1CLFVBQVU7WUFFN0IsT0FBTyxtQkFBbUI7UUFDNUI7a0NBQ0E7UUFDRSxNQUFNLFFBQVEsU0FBUyxJQUFJLFVBQVUsU0FBUyxJQUFJO1FBQ2xEO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNGO0FBRUoiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGluaG5cXE1ZX1BST0pFQ1RzXFx2cGJhbmstaGFja2F0aG9uLTIwMjVcXGFwcHNcXHNyY1xcSW5WaWV3LnRzeCIsIkM6XFxVc2Vyc1xcbGluaG5cXE1ZX1BST0pFQ1RzXFx2cGJhbmstaGFja2F0aG9uLTIwMjVcXGFwcHNcXHNyY1xcb2JzZXJ2ZS50cyIsIkM6XFxVc2Vyc1xcbGluaG5cXE1ZX1BST0pFQ1RzXFx2cGJhbmstaGFja2F0aG9uLTIwMjVcXGFwcHNcXHNyY1xcdXNlSW5WaWV3LnRzeCIsIkM6XFxVc2Vyc1xcbGluaG5cXE1ZX1BST0pFQ1RzXFx2cGJhbmstaGFja2F0aG9uLTIwMjVcXGFwcHNcXHNyY1xcdXNlT25JblZpZXcudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBJbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzLCBQbGFpbkNoaWxkcmVuUHJvcHMgfSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gXCIuL29ic2VydmVcIjtcblxudHlwZSBTdGF0ZSA9IHtcbiAgaW5WaWV3OiBib29sZWFuO1xuICBlbnRyeT86IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk7XG59O1xuXG5mdW5jdGlvbiBpc1BsYWluQ2hpbGRyZW4oXG4gIHByb3BzOiBJbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzIHwgUGxhaW5DaGlsZHJlblByb3BzLFxuKTogcHJvcHMgaXMgUGxhaW5DaGlsZHJlblByb3BzIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9wcy5jaGlsZHJlbiAhPT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAjIyBSZW5kZXIgcHJvcHNcblxuIFRvIHVzZSB0aGUgYDxJblZpZXc+YCBjb21wb25lbnQsIHlvdSBwYXNzIGl0IGEgZnVuY3Rpb24uIEl0IHdpbGwgYmUgY2FsbGVkXG4gd2hlbmV2ZXIgdGhlIHN0YXRlIGNoYW5nZXMsIHdpdGggdGhlIG5ldyB2YWx1ZSBvZiBgaW5WaWV3YC4gSW4gYWRkaXRpb24gdG8gdGhlXG4gYGluVmlld2AgcHJvcCwgY2hpbGRyZW4gYWxzbyByZWNlaXZlIGEgYHJlZmAgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZVxuIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQuIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgd2lsbFxuIG1vbml0b3IuXG5cbiBJZiB5b3UgbmVlZCBpdCwgeW91IGNhbiBhbHNvIGFjY2VzcyB0aGVcbiBbYEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSlcbiBvbiBgZW50cnlgLCBnaXZpbmcgeW91IGFjY2VzcyB0byBhbGwgdGhlIGRldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnQgaW50ZXJzZWN0aW9uXG4gc3RhdGUuXG5cbiBgYGBqc3hcbiBpbXBvcnQgeyBJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuXG4gY29uc3QgQ29tcG9uZW50ID0gKCkgPT4gKFxuIDxJblZpZXc+XG4geyh7IGluVmlldywgcmVmLCBlbnRyeSB9KSA9PiAoXG4gICAgICA8ZGl2IHJlZj17cmVmfT5cbiAgICAgICAgPGgyPntgSGVhZGVyIGluc2lkZSB2aWV3cG9ydCAke2luVmlld30uYH08L2gyPlxuICAgICAgPC9kaXY+XG4gICAgKX1cbiA8L0luVmlldz5cbiApO1xuXG4gZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuIGBgYFxuXG4gIyMgUGxhaW4gY2hpbGRyZW5cblxuIFlvdSBjYW4gcGFzcyBhbnkgZWxlbWVudCB0byB0aGUgYDxJblZpZXcgLz5gLCBhbmQgaXQgd2lsbCBoYW5kbGUgY3JlYXRpbmcgdGhlXG4gd3JhcHBpbmcgRE9NIGVsZW1lbnQuIEFkZCBhIGhhbmRsZXIgdG8gdGhlIGBvbkNoYW5nZWAgbWV0aG9kLCBhbmQgY29udHJvbCB0aGVcbiBzdGF0ZSBpbiB5b3VyIG93biBjb21wb25lbnQuIEFueSBleHRyYSBwcm9wcyB5b3UgYWRkIHRvIGA8SW5WaWV3PmAgd2lsbCBiZVxuIHBhc3NlZCB0byB0aGUgSFRNTCBlbGVtZW50LCBhbGxvd2luZyB5b3Ugc2V0IHRoZSBgY2xhc3NOYW1lYCwgYHN0eWxlYCwgZXRjLlxuXG4gYGBganN4XG4gaW1wb3J0IHsgSW5WaWV3IH0gZnJvbSAncmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcblxuIGNvbnN0IENvbXBvbmVudCA9ICgpID0+IChcbiA8SW5WaWV3IGFzPVwiZGl2XCIgb25DaGFuZ2U9eyhpblZpZXcsIGVudHJ5KSA9PiBjb25zb2xlLmxvZygnSW52aWV3OicsIGluVmlldyl9PlxuIDxoMj5QbGFpbiBjaGlsZHJlbiBhcmUgYWx3YXlzIHJlbmRlcmVkLiBVc2Ugb25DaGFuZ2UgdG8gbW9uaXRvciBzdGF0ZS48L2gyPlxuIDwvSW5WaWV3PlxuICk7XG5cbiBleHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4gYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJblZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMgfCBQbGFpbkNoaWxkcmVuUHJvcHMsXG4gIFN0YXRlXG4+IHtcbiAgbm9kZTogRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBfdW5vYnNlcnZlQ2I6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICBsYXN0SW5WaWV3OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzIHwgUGxhaW5DaGlsZHJlblByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpblZpZXc6ICEhcHJvcHMuaW5pdGlhbEluVmlldyxcbiAgICAgIGVudHJ5OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICB0aGlzLmxhc3RJblZpZXcgPSBwcm9wcy5pbml0aWFsSW5WaWV3O1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bm9ic2VydmUoKTtcbiAgICB0aGlzLm9ic2VydmVOb2RlKCk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzKSB7XG4gICAgLy8gSWYgYSBJbnRlcnNlY3Rpb25PYnNlcnZlciBvcHRpb24gY2hhbmdlZCwgcmVpbml0IHRoZSBvYnNlcnZlclxuICAgIGlmIChcbiAgICAgIHByZXZQcm9wcy5yb290TWFyZ2luICE9PSB0aGlzLnByb3BzLnJvb3RNYXJnaW4gfHxcbiAgICAgIHByZXZQcm9wcy5yb290ICE9PSB0aGlzLnByb3BzLnJvb3QgfHxcbiAgICAgIHByZXZQcm9wcy50aHJlc2hvbGQgIT09IHRoaXMucHJvcHMudGhyZXNob2xkIHx8XG4gICAgICBwcmV2UHJvcHMuc2tpcCAhPT0gdGhpcy5wcm9wcy5za2lwIHx8XG4gICAgICBwcmV2UHJvcHMudHJhY2tWaXNpYmlsaXR5ICE9PSB0aGlzLnByb3BzLnRyYWNrVmlzaWJpbGl0eSB8fFxuICAgICAgcHJldlByb3BzLmRlbGF5ICE9PSB0aGlzLnByb3BzLmRlbGF5XG4gICAgKSB7XG4gICAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICAgICAgdGhpcy5vYnNlcnZlTm9kZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gIH1cblxuICBvYnNlcnZlTm9kZSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZSB8fCB0aGlzLnByb3BzLnNraXApIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICB0aHJlc2hvbGQsXG4gICAgICByb290LFxuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIGRlbGF5LFxuICAgICAgZmFsbGJhY2tJblZpZXcsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAodGhpcy5sYXN0SW5WaWV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubGFzdEluVmlldyA9IHRoaXMucHJvcHMuaW5pdGlhbEluVmlldztcbiAgICB9XG4gICAgdGhpcy5fdW5vYnNlcnZlQ2IgPSBvYnNlcnZlKFxuICAgICAgdGhpcy5ub2RlLFxuICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICB7XG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICAgIGRlbGF5LFxuICAgICAgfSxcbiAgICAgIGZhbGxiYWNrSW5WaWV3LFxuICAgICk7XG4gIH1cblxuICB1bm9ic2VydmUoKSB7XG4gICAgaWYgKHRoaXMuX3Vub2JzZXJ2ZUNiKSB7XG4gICAgICB0aGlzLl91bm9ic2VydmVDYigpO1xuICAgICAgdGhpcy5fdW5vYnNlcnZlQ2IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU5vZGUgPSAobm9kZT86IEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgLy8gQ2xlYXIgdGhlIG9sZCBvYnNlcnZlciwgYmVmb3JlIHdlIHN0YXJ0IG9ic2VydmluZyBhIG5ldyBlbGVtZW50XG4gICAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuXG4gICAgICBpZiAoIW5vZGUgJiYgIXRoaXMucHJvcHMudHJpZ2dlck9uY2UgJiYgIXRoaXMucHJvcHMuc2tpcCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgc3RhdGUgaWYgd2UgZ2V0IGEgbmV3IG5vZGUsIGFuZCB3ZSBhcmVuJ3QgaWdub3JpbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaW5WaWV3OiAhIXRoaXMucHJvcHMuaW5pdGlhbEluVmlldywgZW50cnk6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgdGhpcy5sYXN0SW5WaWV3ID0gdGhpcy5wcm9wcy5pbml0aWFsSW5WaWV3O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubm9kZSA9IG5vZGUgPyBub2RlIDogbnVsbDtcbiAgICB0aGlzLm9ic2VydmVOb2RlKCk7XG4gIH07XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGluVmlldzogYm9vbGVhbiwgZW50cnk6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c0luVmlldyA9IHRoaXMubGFzdEluVmlldztcbiAgICB0aGlzLmxhc3RJblZpZXcgPSBpblZpZXc7XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZlcnkgZmlyc3QgYGZhbHNlYCBub3RpZmljYXRpb24gc28gY29uc3VtZXJzIG9ubHkgaGVhciBhYm91dCBhY3R1YWwgc3RhdGUgY2hhbmdlcy5cbiAgICBpZiAocHJldmlvdXNJblZpZXcgPT09IHVuZGVmaW5lZCAmJiAhaW5WaWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluVmlldyAmJiB0aGlzLnByb3BzLnRyaWdnZXJPbmNlKSB7XG4gICAgICAvLyBJZiBgdHJpZ2dlck9uY2VgIGlzIHRydWUsIHdlIHNob3VsZCBzdG9wIG9ic2VydmluZyB0aGUgZWxlbWVudC5cbiAgICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbkNoaWxkcmVuKHRoaXMucHJvcHMpKSB7XG4gICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBTdGF0ZSwgc28gd2UgY2FuIHBhc3MgaXQgdG8gdGhlIGNoaWxkcmVuIGluIHRoZSBuZXh0IHJlbmRlciB1cGRhdGVcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gcmVhc29uIHRvIHVwZGF0ZSB0aGUgc3RhdGUgZm9yIHBsYWluIGNoaWxkcmVuLCBzaW5jZSBpdCdzIG5vdCB1c2VkIGluIHRoZSByZW5kZXJpbmcuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgaW5WaWV3LCBlbnRyeSB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGFjdGl2ZWx5IGxpc3RlbmluZyBmb3Igb25DaGFuZ2UsIGFsd2F5cyB0cmlnZ2VyIGl0XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGluVmlldywgZW50cnkpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHsgaW5WaWV3LCBlbnRyeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHJldHVybiBjaGlsZHJlbih7IGluVmlldywgZW50cnksIHJlZjogdGhpcy5oYW5kbGVOb2RlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGFzLFxuICAgICAgdHJpZ2dlck9uY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICByb290LFxuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIG9uQ2hhbmdlLFxuICAgICAgc2tpcCxcbiAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIGRlbGF5LFxuICAgICAgaW5pdGlhbEluVmlldyxcbiAgICAgIGZhbGxiYWNrSW5WaWV3LFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wcyBhcyBQbGFpbkNoaWxkcmVuUHJvcHM7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIGFzIHx8IFwiZGl2XCIsXG4gICAgICB7IHJlZjogdGhpcy5oYW5kbGVOb2RlLCAuLi5wcm9wcyB9LFxuICAgICAgY2hpbGRyZW4sXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBPYnNlcnZlckluc3RhbmNlQ2FsbGJhY2sgfSBmcm9tIFwiLi9pbmRleFwiO1xuXG5jb25zdCBvYnNlcnZlck1hcCA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGVsZW1lbnRzOiBNYXA8RWxlbWVudCwgQXJyYXk8T2JzZXJ2ZXJJbnN0YW5jZUNhbGxiYWNrPj47XG4gIH1cbj4oKTtcblxuY29uc3QgUm9vdElkczogV2Vha01hcDxFbGVtZW50IHwgRG9jdW1lbnQsIHN0cmluZz4gPSBuZXcgV2Vha01hcCgpO1xubGV0IHJvb3RJZCA9IDA7XG5cbmxldCB1bnN1cHBvcnRlZFZhbHVlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIFdoYXQgc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyB1bnN1cHBvcnRlZD9cbiAqIElkZWFsbHkgdGhlIHBvbHlmaWxsIGhhcyBiZWVuIGxvYWRlZCwgeW91IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcgaGFwcGVuOlxuICogLSBgdW5kZWZpbmVkYDogVGhyb3cgYW4gZXJyb3JcbiAqIC0gYHRydWVgIG9yIGBmYWxzZWA6IFNldCB0aGUgYGluVmlld2AgdmFsdWUgdG8gdGhpcyByZWdhcmRsZXNzIG9mIGludGVyc2VjdGlvbiBzdGF0ZVxuICogKiovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEZhbGxiYWNrSW5WaWV3KGluVmlldzogYm9vbGVhbiB8IHVuZGVmaW5lZCkge1xuICB1bnN1cHBvcnRlZFZhbHVlID0gaW5WaWV3O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0gcm9vdFxuICovXG5mdW5jdGlvbiBnZXRSb290SWQocm9vdDogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0W1wicm9vdFwiXSkge1xuICBpZiAoIXJvb3QpIHJldHVybiBcIjBcIjtcbiAgaWYgKFJvb3RJZHMuaGFzKHJvb3QpKSByZXR1cm4gUm9vdElkcy5nZXQocm9vdCk7XG4gIHJvb3RJZCArPSAxO1xuICBSb290SWRzLnNldChyb290LCByb290SWQudG9TdHJpbmcoKSk7XG4gIHJldHVybiBSb290SWRzLmdldChyb290KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBvcHRpb25zIHRvIGEgc3RyaW5nIElkLCBiYXNlZCBvbiB0aGUgdmFsdWVzLlxuICogRW5zdXJlcyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgb2JzZXJ2ZXIgd2hlbiBvYnNlcnZpbmcgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbnNUb0lkKG9wdGlvbnM6IEludGVyc2VjdGlvbk9ic2VydmVySW5pdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAuc29ydCgpXG4gICAgLmZpbHRlcihcbiAgICAgIChrZXkpID0+IG9wdGlvbnNba2V5IGFzIGtleW9mIEludGVyc2VjdGlvbk9ic2VydmVySW5pdF0gIT09IHVuZGVmaW5lZCxcbiAgICApXG4gICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gYCR7a2V5fV8ke1xuICAgICAgICBrZXkgPT09IFwicm9vdFwiXG4gICAgICAgICAgPyBnZXRSb290SWQob3B0aW9ucy5yb290KVxuICAgICAgICAgIDogb3B0aW9uc1trZXkgYXMga2V5b2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XVxuICAgICAgfWA7XG4gICAgfSlcbiAgICAudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KSB7XG4gIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBvYnNlcnZlciBpbnN0YW5jZSwgYmFzZWQgb24gdGhlIHJvb3QsIHJvb3QgbWFyZ2luIGFuZCB0aHJlc2hvbGQuXG4gIGNvbnN0IGlkID0gb3B0aW9uc1RvSWQob3B0aW9ucyk7XG4gIGxldCBpbnN0YW5jZSA9IG9ic2VydmVyTWFwLmdldChpZCk7XG5cbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBlbGVtZW50cyB0aGlzIG9ic2VydmVyIGlzIGdvaW5nIHRvIG9ic2VydmUuIEVhY2ggZWxlbWVudCBoYXMgYSBsaXN0IG9mIGNhbGxiYWNrcyB0aGF0IHNob3VsZCBiZSB0cmlnZ2VyZWQsIG9uY2UgaXQgY29tZXMgaW50byB2aWV3LlxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcDxFbGVtZW50LCBBcnJheTxPYnNlcnZlckluc3RhbmNlQ2FsbGJhY2s+PigpO1xuICAgIGxldCB0aHJlc2hvbGRzOiBudW1iZXJbXSB8IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgLy8gV2hpbGUgaXQgd291bGQgYmUgbmljZSBpZiB5b3UgY291bGQganVzdCBsb29rIGF0IGlzSW50ZXJzZWN0aW5nIHRvIGRldGVybWluZSBpZiB0aGUgY29tcG9uZW50IGlzIGluc2lkZSB0aGUgdmlld3BvcnQsIGJyb3dzZXJzIGNhbid0IGFncmVlIG9uIGhvdyB0byB1c2UgaXQuXG4gICAgICAgIC8vIC1GaXJlZm94IGlnbm9yZXMgYHRocmVzaG9sZGAgd2hlbiBjb25zaWRlcmluZyBgaXNJbnRlcnNlY3RpbmdgLCBzbyBpdCB3aWxsIG5ldmVyIGJlIGZhbHNlIGFnYWluIGlmIGB0aHJlc2hvbGRgIGlzID4gMFxuICAgICAgICBjb25zdCBpblZpZXcgPVxuICAgICAgICAgIGVudHJ5LmlzSW50ZXJzZWN0aW5nICYmXG4gICAgICAgICAgdGhyZXNob2xkcy5zb21lKCh0aHJlc2hvbGQpID0+IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID49IHRocmVzaG9sZCk7XG5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdXBwb3J0IEludGVyc2VjdGlvbk9ic2VydmVyIHYyXG4gICAgICAgIGlmIChvcHRpb25zLnRyYWNrVmlzaWJpbGl0eSAmJiB0eXBlb2YgZW50cnkuaXNWaXNpYmxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgLy8gVGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEludGVyc2VjdGlvbiBPYnNlcnZlciB2MiwgZmFsbGluZyBiYWNrIHRvIHYxIGJlaGF2aW9yLlxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBlbnRyeS5pc1Zpc2libGUgPSBpblZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KT8uZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhpblZpZXcsIGVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgdmFsaWQgdGhyZXNob2xkcyBhcnJheS4gSWYgbm90LCB1c2UgdGhlIHRocmVzaG9sZCBmcm9tIHRoZSBvcHRpb25zXG4gICAgdGhyZXNob2xkcyA9XG4gICAgICBvYnNlcnZlci50aHJlc2hvbGRzIHx8XG4gICAgICAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRocmVzaG9sZClcbiAgICAgICAgPyBvcHRpb25zLnRocmVzaG9sZFxuICAgICAgICA6IFtvcHRpb25zLnRocmVzaG9sZCB8fCAwXSk7XG5cbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICBlbGVtZW50cyxcbiAgICB9O1xuXG4gICAgb2JzZXJ2ZXJNYXAuc2V0KGlkLCBpbnN0YW5jZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIGVsZW1lbnQgLSBET00gRWxlbWVudCB0byBvYnNlcnZlXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0byB0cmlnZ2VyIHdoZW4gaW50ZXJzZWN0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEludGVyc2VjdGlvbiBPYnNlcnZlciBvcHRpb25zXG4gKiBAcGFyYW0gZmFsbGJhY2tJblZpZXcgLSBGYWxsYmFjayBpblZpZXcgdmFsdWUuXG4gKiBAcmV0dXJuIEZ1bmN0aW9uIC0gQ2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSB0cmlnZ2VyZWQgdG8gdW5yZWdpc3RlciB0aGUgb2JzZXJ2ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNhbGxiYWNrOiBPYnNlcnZlckluc3RhbmNlQ2FsbGJhY2ssXG4gIG9wdGlvbnM6IEludGVyc2VjdGlvbk9ic2VydmVySW5pdCA9IHt9LFxuICBmYWxsYmFja0luVmlldyA9IHVuc3VwcG9ydGVkVmFsdWUsXG4pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICBmYWxsYmFja0luVmlldyAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGNvbnN0IGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY2FsbGJhY2soZmFsbGJhY2tJblZpZXcsIHtcbiAgICAgIGlzSW50ZXJzZWN0aW5nOiBmYWxsYmFja0luVmlldyxcbiAgICAgIHRhcmdldDogZWxlbWVudCxcbiAgICAgIGludGVyc2VjdGlvblJhdGlvOlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy50aHJlc2hvbGQgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnRocmVzaG9sZCA6IDAsXG4gICAgICB0aW1lOiAwLFxuICAgICAgYm91bmRpbmdDbGllbnRSZWN0OiBib3VuZHMsXG4gICAgICBpbnRlcnNlY3Rpb25SZWN0OiBib3VuZHMsXG4gICAgICByb290Qm91bmRzOiBib3VuZHMsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gY2xlYW51cFxuICAgIH07XG4gIH1cbiAgLy8gQW4gb2JzZXJ2ZXIgd2l0aCB0aGUgc2FtZSBvcHRpb25zIGNhbiBiZSByZXVzZWQsIHNvIGxldHMgdXNlIHRoaXMgZmFjdFxuICBjb25zdCB7IGlkLCBvYnNlcnZlciwgZWxlbWVudHMgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuXG4gIC8vIFJlZ2lzdGVyIHRoZSBjYWxsYmFjayBsaXN0ZW5lciBmb3IgdGhpcyBlbGVtZW50XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGVsZW1lbnRzLmdldChlbGVtZW50KSB8fCBbXTtcbiAgaWYgKCFlbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2tzKTtcbiAgfVxuXG4gIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcblxuICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSB0aGUgY2FsbGJhY2sgbGlzdFxuICAgIGNhbGxiYWNrcy5zcGxpY2UoY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcblxuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBObyBtb3JlIGNhbGxiYWNrIGV4aXN0cyBmb3IgZWxlbWVudCwgc28gZGVzdHJveSBpdFxuICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICAvLyBObyBtb3JlIGVsZW1lbnRzIGFyZSBiZWluZyBvYnNlcnZlciBieSB0aGlzIGluc3RhbmNlLCBzbyBkZXN0cm95IGl0XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBvYnNlcnZlck1hcC5kZWxldGUoaWQpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBJbnRlcnNlY3Rpb25PcHRpb25zLCBJblZpZXdIb29rUmVzcG9uc2UgfSBmcm9tIFwiLi9pbmRleFwiO1xuaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gXCIuL29ic2VydmVcIjtcblxudHlwZSBTdGF0ZSA9IHtcbiAgaW5WaWV3OiBib29sZWFuO1xuICBlbnRyeT86IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk7XG59O1xuXG4vKipcbiAqIFJlYWN0IEhvb2tzIG1ha2UgaXQgZWFzeSB0byBtb25pdG9yIHRoZSBgaW5WaWV3YCBzdGF0ZSBvZiB5b3VyIGNvbXBvbmVudHMuIENhbGxcbiAqIHRoZSBgdXNlSW5WaWV3YCBob29rIHdpdGggdGhlIChvcHRpb25hbCkgW29wdGlvbnNdKCNvcHRpb25zKSB5b3UgbmVlZC4gSXQgd2lsbFxuICogcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBgcmVmYCwgdGhlIGBpblZpZXdgIHN0YXR1cyBhbmQgdGhlIGN1cnJlbnRcbiAqIFtgZW50cnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkuXG4gKiBBc3NpZ24gdGhlIGByZWZgIHRvIHRoZSBET00gZWxlbWVudCB5b3Ugd2FudCB0byBtb25pdG9yLCBhbmQgdGhlIGhvb2sgd2lsbFxuICogcmVwb3J0IHRoZSBzdGF0dXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IHVzZUluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XG4gKlxuICogY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCB7IHJlZiwgaW5WaWV3LCBlbnRyeSB9ID0gdXNlSW5WaWV3KHtcbiAqICAgICAgIHRocmVzaG9sZDogMCxcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxkaXYgcmVmPXtyZWZ9PlxuICogICAgICAgPGgyPntgSGVhZGVyIGluc2lkZSB2aWV3cG9ydCAke2luVmlld30uYH08L2gyPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5WaWV3KHtcbiAgdGhyZXNob2xkLFxuICBkZWxheSxcbiAgdHJhY2tWaXNpYmlsaXR5LFxuICByb290TWFyZ2luLFxuICByb290LFxuICB0cmlnZ2VyT25jZSxcbiAgc2tpcCxcbiAgaW5pdGlhbEluVmlldyxcbiAgZmFsbGJhY2tJblZpZXcsXG4gIG9uQ2hhbmdlLFxufTogSW50ZXJzZWN0aW9uT3B0aW9ucyA9IHt9KTogSW5WaWV3SG9va1Jlc3BvbnNlIHtcbiAgY29uc3QgW3JlZiwgc2V0UmVmXSA9IFJlYWN0LnVzZVN0YXRlPEVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FsbGJhY2sgPSBSZWFjdC51c2VSZWY8SW50ZXJzZWN0aW9uT3B0aW9uc1tcIm9uQ2hhbmdlXCJdPihvbkNoYW5nZSk7XG4gIGNvbnN0IGxhc3RJblZpZXdSZWYgPSBSZWFjdC51c2VSZWY8Ym9vbGVhbiB8IHVuZGVmaW5lZD4oaW5pdGlhbEluVmlldyk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGU8U3RhdGU+KHtcbiAgICBpblZpZXc6ICEhaW5pdGlhbEluVmlldyxcbiAgICBlbnRyeTogdW5kZWZpbmVkLFxuICB9KTtcblxuICAvLyBTdG9yZSB0aGUgb25DaGFuZ2UgY2FsbGJhY2sgaW4gYSBgcmVmYCwgc28gd2UgY2FuIGFjY2VzcyB0aGUgbGF0ZXN0IGluc3RhbmNlXG4gIC8vIGluc2lkZSB0aGUgYHVzZUVmZmVjdGAsIGJ1dCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZXJlbmRlci5cbiAgY2FsbGJhY2suY3VycmVudCA9IG9uQ2hhbmdlO1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IHRocmVzaG9sZCBpcyBub3QgY29ycmVjdGx5IGRldGVjdGVkIGFzIGEgZGVwZW5kZW5jeVxuICBSZWFjdC51c2VFZmZlY3QoXG4gICAgKCkgPT4ge1xuICAgICAgaWYgKGxhc3RJblZpZXdSZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhc3RJblZpZXdSZWYuY3VycmVudCA9IGluaXRpYWxJblZpZXc7XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBub2RlIHJlZiwgYW5kIHRoYXQgd2Ugc2hvdWxkbid0IHNraXAgb2JzZXJ2aW5nXG4gICAgICBpZiAoc2tpcCB8fCAhcmVmKSByZXR1cm47XG5cbiAgICAgIGxldCB1bm9ic2VydmU6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICAgIHVub2JzZXJ2ZSA9IG9ic2VydmUoXG4gICAgICAgIHJlZixcbiAgICAgICAgKGluVmlldywgZW50cnkpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0luVmlldyA9IGxhc3RJblZpZXdSZWYuY3VycmVudDtcbiAgICAgICAgICBsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPSBpblZpZXc7XG5cbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIHZlcnkgZmlyc3QgYGZhbHNlYCBub3RpZmljYXRpb24gc28gY29uc3VtZXJzIG9ubHkgaGVhciBhYm91dCBhY3R1YWwgc3RhdGUgY2hhbmdlcy5cbiAgICAgICAgICBpZiAocHJldmlvdXNJblZpZXcgPT09IHVuZGVmaW5lZCAmJiAhaW5WaWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5WaWV3LFxuICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLmN1cnJlbnQpIGNhbGxiYWNrLmN1cnJlbnQoaW5WaWV3LCBlbnRyeSk7XG5cbiAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcgJiYgdHJpZ2dlck9uY2UgJiYgdW5vYnNlcnZlKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBzaG91bGQgb25seSB0cmlnZ2VyIG9uY2UsIHVub2JzZXJ2ZSB0aGUgZWxlbWVudCBhZnRlciBpdCdzIGluVmlld1xuICAgICAgICAgICAgdW5vYnNlcnZlKCk7XG4gICAgICAgICAgICB1bm9ic2VydmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICB9LFxuICAgICAgICBmYWxsYmFja0luVmlldyxcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICh1bm9ic2VydmUpIHtcbiAgICAgICAgICB1bm9ic2VydmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIFdlIGJyZWFrIHRoZSBydWxlIGhlcmUsIGJlY2F1c2Ugd2UgYXJlbid0IGluY2x1ZGluZyB0aGUgYWN0dWFsIGB0aHJlc2hvbGRgIHZhcmlhYmxlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgIC8vIElmIHRoZSB0aHJlc2hvbGQgaXMgYW4gYXJyYXksIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcsIHNvIGl0IHdvbid0IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICBBcnJheS5pc0FycmF5KHRocmVzaG9sZCkgPyB0aHJlc2hvbGQudG9TdHJpbmcoKSA6IHRocmVzaG9sZCxcbiAgICAgIHJlZixcbiAgICAgIHJvb3QsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgdHJpZ2dlck9uY2UsXG4gICAgICBza2lwLFxuICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgZmFsbGJhY2tJblZpZXcsXG4gICAgICBkZWxheSxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IGVudHJ5VGFyZ2V0ID0gc3RhdGUuZW50cnk/LnRhcmdldDtcbiAgY29uc3QgcHJldmlvdXNFbnRyeVRhcmdldCA9IFJlYWN0LnVzZVJlZjxFbGVtZW50IHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBpZiAoXG4gICAgIXJlZiAmJlxuICAgIGVudHJ5VGFyZ2V0ICYmXG4gICAgIXRyaWdnZXJPbmNlICYmXG4gICAgIXNraXAgJiZcbiAgICBwcmV2aW91c0VudHJ5VGFyZ2V0LmN1cnJlbnQgIT09IGVudHJ5VGFyZ2V0XG4gICkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBub2RlIHJlZiwgdGhlbiByZXNldCB0aGUgc3RhdGUgKHVubGVzcyB0aGUgaG9vayBpcyBzZXQgdG8gb25seSBgdHJpZ2dlck9uY2VgIG9yIGBza2lwYClcbiAgICAvLyBUaGlzIGVuc3VyZXMgd2UgY29ycmVjdGx5IHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUgLSBJZiB5b3UgYXJlbid0IG9ic2VydmluZyBhbnl0aGluZywgdGhlbiBub3RoaW5nIGlzIGluVmlld1xuICAgIHByZXZpb3VzRW50cnlUYXJnZXQuY3VycmVudCA9IGVudHJ5VGFyZ2V0O1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGluVmlldzogISFpbml0aWFsSW5WaWV3LFxuICAgICAgZW50cnk6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgICBsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPSBpbml0aWFsSW5WaWV3O1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gW3NldFJlZiwgc3RhdGUuaW5WaWV3LCBzdGF0ZS5lbnRyeV0gYXMgSW5WaWV3SG9va1Jlc3BvbnNlO1xuXG4gIC8vIFN1cHBvcnQgb2JqZWN0IGRlc3RydWN0dXJpbmcsIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWMgdmFsdWVzLlxuICByZXN1bHQucmVmID0gcmVzdWx0WzBdO1xuICByZXN1bHQuaW5WaWV3ID0gcmVzdWx0WzFdO1xuICByZXN1bHQuZW50cnkgPSByZXN1bHRbMl07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBJbnRlcnNlY3Rpb25DaGFuZ2VFZmZlY3QsXG4gIEludGVyc2VjdGlvbkVmZmVjdE9wdGlvbnMsXG59IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgeyBvYnNlcnZlIH0gZnJvbSBcIi4vb2JzZXJ2ZVwiO1xuXG5jb25zdCB1c2VTeW5jRWZmZWN0ID1cbiAgKFxuICAgIFJlYWN0IGFzIHR5cGVvZiBSZWFjdCAmIHtcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdD86IHR5cGVvZiBSZWFjdC51c2VFZmZlY3Q7XG4gICAgfVxuICApLnVzZUluc2VydGlvbkVmZmVjdCA/P1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QgPz9cbiAgUmVhY3QudXNlRWZmZWN0O1xuXG4vKipcbiAqIFJlYWN0IEhvb2tzIG1ha2UgaXQgZWFzeSB0byBtb25pdG9yIHdoZW4gZWxlbWVudHMgY29tZSBpbnRvIGFuZCBsZWF2ZSB2aWV3LiBDYWxsXG4gKiB0aGUgYHVzZU9uSW5WaWV3YCBob29rIHdpdGggeW91ciBjYWxsYmFjayBhbmQgKG9wdGlvbmFsKSBbb3B0aW9uc10oI29wdGlvbnMpLlxuICogSXQgd2lsbCByZXR1cm4gYSByZWYgY2FsbGJhY2sgdGhhdCB5b3UgY2FuIGFzc2lnbiB0byB0aGUgRE9NIGVsZW1lbnQgeW91IHdhbnQgdG8gbW9uaXRvci5cbiAqIFdoZW4gdGhlIGVsZW1lbnQgZW50ZXJzIG9yIGxlYXZlcyB0aGUgdmlld3BvcnQsIHlvdXIgY2FsbGJhY2sgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gKlxuICogVGhpcyBob29rIHRyaWdnZXJzIG5vIHJlLXJlbmRlcnMsIGFuZCBpcyB1c2VmdWwgZm9yIHBlcmZvcm1hbmNlLWNyaXRpY2FsIHVzZS1jYXNlcyBvclxuICogd2hlbiB5b3UgbmVlZCB0byB0cmlnZ2VyIHJlbmRlciBpbmRlcGVuZGVudCBzaWRlIGVmZmVjdHMgbGlrZSB0cmFja2luZyBvciBsb2dnaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKiBpbXBvcnQgeyB1c2VPbkluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XG4gKlxuICogY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBpblZpZXdSZWYgPSB1c2VPbkluVmlldygoaW5WaWV3LCBlbnRyeSkgPT4ge1xuICogICAgIGlmIChpblZpZXcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudCBpcyBpbiB2aWV3XCIsIGVudHJ5LnRhcmdldCk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudCBsZWZ0IHZpZXdcIiwgZW50cnkudGFyZ2V0KTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2IHJlZj17aW5WaWV3UmVmfT5cbiAqICAgICAgIDxoMj5UaGlzIGVsZW1lbnQgaXMgYmVpbmcgbW9uaXRvcmVkPC9oMj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH07XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZU9uSW5WaWV3ID0gPFRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oXG4gIG9uSW50ZXJzZWN0aW9uQ2hhbmdlOiBJbnRlcnNlY3Rpb25DaGFuZ2VFZmZlY3Q8VEVsZW1lbnQ+LFxuICB7XG4gICAgdGhyZXNob2xkLFxuICAgIHJvb3QsXG4gICAgcm9vdE1hcmdpbixcbiAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgZGVsYXksXG4gICAgdHJpZ2dlck9uY2UsXG4gICAgc2tpcCxcbiAgfTogSW50ZXJzZWN0aW9uRWZmZWN0T3B0aW9ucyA9IHt9LFxuKSA9PiB7XG4gIGNvbnN0IG9uSW50ZXJzZWN0aW9uQ2hhbmdlUmVmID0gUmVhY3QudXNlUmVmKG9uSW50ZXJzZWN0aW9uQ2hhbmdlKTtcbiAgY29uc3Qgb2JzZXJ2ZWRFbGVtZW50UmVmID0gUmVhY3QudXNlUmVmPFRFbGVtZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IG9ic2VydmVyQ2xlYW51cFJlZiA9IFJlYWN0LnVzZVJlZjwoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IGxhc3RJblZpZXdSZWYgPSBSZWFjdC51c2VSZWY8Ym9vbGVhbiB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICB1c2VTeW5jRWZmZWN0KCgpID0+IHtcbiAgICBvbkludGVyc2VjdGlvbkNoYW5nZVJlZi5jdXJyZW50ID0gb25JbnRlcnNlY3Rpb25DaGFuZ2U7XG4gIH0sIFtvbkludGVyc2VjdGlvbkNoYW5nZV0pO1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IFRocmVzaG9sZCBhcnJheXMgYXJlIG5vcm1hbGl6ZWQgaW5zaWRlIHRoZSBjYWxsYmFja1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsZW1lbnQ6IFRFbGVtZW50IHwgdW5kZWZpbmVkIHwgbnVsbCkgPT4ge1xuICAgICAgLy8gUmVhY3QgPDE5IG5ldmVyIGNhbGxzIHJlZiBjYWxsYmFja3Mgd2l0aCBgbnVsbGAgZHVyaW5nIHVubW91bnQsIHNvIHdlXG4gICAgICAvLyBlYWdlcmx5IHRlYXIgZG93biBleGlzdGluZyBvYnNlcnZlcnMgbWFudWFsbHkgd2hlbmV2ZXIgdGhlIHRhcmdldCBjaGFuZ2VzLlxuICAgICAgY29uc3QgY2xlYW51cEV4aXN0aW5nID0gKCkgPT4ge1xuICAgICAgICBpZiAob2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwID0gb2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgb2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gb2JzZXJ2ZWRFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgc2tpcCkge1xuICAgICAgICBjbGVhbnVwRXhpc3RpbmcoKTtcbiAgICAgICAgb2JzZXJ2ZWRFbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xlYW51cEV4aXN0aW5nKCk7XG5cbiAgICAgIG9ic2VydmVkRWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgIGxldCBkZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgY29uc3QgZGVzdHJveU9ic2VydmVyID0gb2JzZXJ2ZShcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgKGluVmlldywgZW50cnkpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0luVmlldyA9IGxhc3RJblZpZXdSZWYuY3VycmVudDtcbiAgICAgICAgICBsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPSBpblZpZXc7XG5cbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIHZlcnkgZmlyc3QgYGZhbHNlYCBub3RpZmljYXRpb24gc28gY29uc3VtZXJzIG9ubHkgaGVhciBhYm91dCBhY3R1YWwgc3RhdGUgY2hhbmdlcy5cbiAgICAgICAgICBpZiAocHJldmlvdXNJblZpZXcgPT09IHVuZGVmaW5lZCAmJiAhaW5WaWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb25JbnRlcnNlY3Rpb25DaGFuZ2VSZWYuY3VycmVudChcbiAgICAgICAgICAgIGluVmlldyxcbiAgICAgICAgICAgIGVudHJ5IGFzIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgJiB7IHRhcmdldDogVEVsZW1lbnQgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh0cmlnZ2VyT25jZSAmJiBpblZpZXcpIHtcbiAgICAgICAgICAgIHN0b3BPYnNlcnZpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgICAgICBkZWxheSxcbiAgICAgICAgfSBhcyBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQsXG4gICAgICApO1xuXG4gICAgICBmdW5jdGlvbiBzdG9wT2JzZXJ2aW5nKCkge1xuICAgICAgICAvLyBDZW50cmFsaXplZCB0ZWFyZG93biBzbyBib3RoIG1hbnVhbCBkZXN0cm95cyBhbmQgUmVhY3QgcmVmIHVwZGF0ZXMgc2hhcmVcbiAgICAgICAgLy8gdGhlIHNhbWUgY2xlYW51cCBwYXRoIChuZWVkZWQgZm9yIFJlYWN0IHZlcnNpb25zIHRoYXQgbmV2ZXIgY2FsbCB0aGUgcmVmIHdpdGggYG51bGxgKS5cbiAgICAgICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBkZXN0cm95T2JzZXJ2ZXIoKTtcbiAgICAgICAgb2JzZXJ2ZWRFbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEluVmlld1JlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudCA9IHN0b3BPYnNlcnZpbmc7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudDtcbiAgICB9LFxuICAgIFtcbiAgICAgIEFycmF5LmlzQXJyYXkodGhyZXNob2xkKSA/IHRocmVzaG9sZC50b1N0cmluZygpIDogdGhyZXNob2xkLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICBkZWxheSxcbiAgICAgIHRyaWdnZXJPbmNlLFxuICAgICAgc2tpcCxcbiAgICBdLFxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJfYSIsIlJlYWN0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-intersection-observer/dist/index.mjs\n");

/***/ })

};
;